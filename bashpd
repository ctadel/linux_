################################################
#
##          __              .___     .__      ##
##    _____/  |______     __| _/____ |  |     ##
##  _/ ___\   __\__  \   / __ |/ __ \|  |     ##
##  \  \___|  |  / __ \_/ /_/ \  ___/|  |__   ##
##   \___  >__| (____  /\____ |\___  >____/   ##
##       \/          \/      \/    \/         ##
################################################

red=$(tput setaf 1)
green=$(tput setaf 2)
blue=$(tput setaf 4)
normal=$(tput sgr0)
COLORTERM="truecolor"

export PAGER=more
export EDITOR=vi

function extract {
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
 else
    for n in "$@"
    do
      if [ -f "$n" ] ; then
          case "${n%,}" in
            *.cbt|*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar) 
                         tar xvf "$n"       ;;
            *.lzma)      unlzma ./"$n"      ;;
            *.bz2)       bunzip2 ./"$n"     ;;
            *.cbr|*.rar) unrar x -ad ./"$n" ;;
            *.gz)        gunzip ./"$n"      ;;
            *.cbz|*.epub|*.zip) unzip ./"$n"       ;;
            *.z)         uncompress ./"$n"  ;;
            *.7z|*.apk|*.arj|*.cab|*.cb7|*.chm|*.deb|*.dmg|*.iso|*.lzh|*.msi|*.pkg|*.rpm|*.udf|*.wim|*.xar)
                         7z x ./"$n"        ;;
            *.xz)        unxz ./"$n"        ;;
            *.exe)       cabextract ./"$n"  ;;
            *.cpio)      cpio -id < ./"$n"  ;;
            *.cba|*.ace) unace x ./"$n"      ;;
            *.zpaq)      zpaq x ./"$n"      ;;
            *.arc)       arc e ./"$n"       ;;
            *.cso)       ciso 0 ./"$n" ./"$n.iso" && \
                              extract $n.iso && \rm -f $n ;;
            *)
                         echo "extract: '$n' - unknown archive method"
                         return 1
                         ;;
          esac
      else
          echo "'$n' - file does not exist"
          return 1
      fi
    done
fi
}

# Directory settings
alias ..='cd ..'
alias l='ls -ltrah'

dotSlash=""
for i in 1 2 3 4
do
    dotSlash=${dotSlash}'../';
    baseName=".${i}"
    alias $baseName="cd ${dotSlash}"
done

function fn (){
   local keyword=$1
   shift
   local args="$*"
   if [[ $args ]]
   then
       args="$(sed 's/ / |grep -i /g' <<<$args)"
       local CMD="/usr/bin/find -iname $keyword |grep -i $args"
       eval $CMD
       return 0;
   fi
   local CMD="/usr/bin/find -iname $keyword"
   eval $CMD
}

alias kill9='kill -9 %'

#Python
alias pym='python manage.py'
alias pymr='python manage.py runserver 0.0.0.0:8000'


########################################| GIT SETTINGS START |########################################

alias gl='git log --graph'
alias grl='git reflog'
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git pull'
alias go='git checkout'
alias goa='git checkout .'
alias gd='git diff'
alias gdc='git diff --cached'
alias gg='git grep'
alias gb='git branch'
alias gsl='git stash list'
alias gw='git worktree'

#QuickSave Imlementation
alias quicksee='git stash show $(git stash list | grep "__QuickSave__" | cut -d: -f1)'

function quicksave(){
    quickstash=$(git stash list | grep "__QuickSave__" | cut -d: -f1)
    if [[ $quickstash =~ ^stash ]];then
        git stash drop $quickstash
    fi
    git stash save -u __QuickSave__
    git stash apply $(git stash list | grep "__QuickSave__" | cut -d: -f1)
    printf "\n${green}QuickSaved current changes to stash..${normal}\n"
}

function quickapply(){
    files=$(''git status | awk 'BEGIN{ORS=" "} /modified:/ {print $2}' '')
    if ! [ -z "$files" ]
    then
        read -p "Keep current changes?(yes/*): " confirm 
        if [[ $confirm == [yY] || $confirm == [yY][eE][sS] ]];then
            git stash save -u
        else
            git checkout .
        fi
    fi

    quickstash=$(git stash list | grep "__QuickSave__" | cut -d: -f1)
    if [[ $quickstash =~ ^stash ]];then
        git stash apply $quickstash
        printf "\n${blue}Applied QuickSave data from stash..${normal}\n"
    else
        printf "\n${red}No QuickSave available in the stash..${normal}\n"
    fi
}

#Backup Files for git
function bas(){
    if [ $1 ]
    then
        for file in $*
        do
            if [ -f $file ]; then
                cp -f $file $file.bak
                go $file
            else
                echo "$file doesn't exist."
            fi
        done
    else
        #Srcipt to backup unstaged files from git repo.
        echo "Saving all unstaged files to changes.zip"
        files=$(''git status | awk 'BEGIN{ORS=" "} /modified:/ {print $2}' '')
        if [ -f changes.zip ]
        then
            echo "changes.zip already exists.."
        else
            zip changes.zip $files
            if [ -f changes.zip ]
            then
                echo "Reseting all files to HEAD..."
                git checkout . 
                git status
            else
                echo "Error creating the zip archieve."
            fi
        fi
    fi
}

function bar(){
    if [ $1 ]
    then
        for file in $*
        do
            if [ -f $file.bak ]; then
                mv -f $file.bak $file
            else
                echo "No backup for $file."
            fi
        done
    else
        if [ -f changes.zip ]
        then
            unzip ./changes.zip
            read -p "Delete changes.zip?(yes/*): " confirm 
            if [[ $confirm == [yY] || $confirm == [yY][eE][sS] ]]
            then
                rm changes.zip
            else
                echo "${green}changes.zip is preserved...${normal}"
            fi
        fi
        
    fi
}

########################################| GIT SETTINGS END |########################################


alias pubip='curl ifconfig.co'

if [ -d ~/gitlib/linux_ ]; then 
    alias lin_="cd ~/gitlib/linux_"
    export LIN_="/home/$USER/gitlib/linux_"
fi

#incognito command
alias pvt='history -d $((HISTCMD-1)) && '

function pingx(){
    if [ -z $1 ];then 
        echo "Pinging google.com"
        ping google.com | awk 'BEGIN{ORS="\t"}{print substr($8,6,10)}'
    else
        echo "Pinging $1"
        ping $1 | awk 'BEGIN{ORS="\t"}{print substr($8,6,10)}'
    fi
}

if [ -f  /usr/bin/nvim ]; then
  alias vi='nvim'
fi

if [ -f  /usr/bin/lvim ]; then
  alias vi='lvim'
fi

if [ -f  /usr/bin/fzf ]; then
  alias f='fzf -f'
fi

if [ -f /usr/bin/xsel ] || [ -f ~/usr/bin/xsel ]; then
  alias copy='xsel -b'
fi

if [ -f  /usr/bin/psql ]; then
    alias psql="psql --set PROMPT1='%[%033[0;34m%]%(LOCAL) %[%033[0m%]%/%R%# '"
    alias tipsql="psql -h192.168.1.208 -dtradein_clients -Utradein  --set PROMPT1='%[%033[0;36m%]%(LOCAL) %[%033[0m%]%/%R%# '"
    alias rpsql="psql -h34.93.71.99 -dtradein_clients -Utradein_dev --set PROMPT1='%[%033[0;31m%]%(REMOTE) %[%033[0m%]%/%R%# '"
fi
# include .server_settings if it exists
if [ -f $HOME/.server_settings ]; then
    . $HOME/.server_settings
fi

alias notify="notify-send 'Process Completed' 'Please have a look in the terminal' -u 'normal' && /home/prajwal/.local/bin/alert"

function got() {
    # Handle flags
    local new_branch=false
    local migration=false
    local branch_name=""
    while [ $# -gt 0 ]; do
      case $1 in
        --new|-n)
          new_branch=true
          ;;
        *)
          branch_name="$1"
          ;;
      esac
      shift
    done

    # Check if current directory is inside a Git repository
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        echo "Error: Not a Git repository" >&2
        return 1
    fi

    repo_path=$(git worktree list | awk 'NR==1{print $1}')

    # Check if branch name argument is provided
    if [[ -n "$branch_name" ]]; then
        # Get list of worktrees
        local worktree_list=$(git worktree list)

        # Loop through worktrees to find branch
        local branch_dir=""
        while read -r line; do
            local dir=$(echo "$line" | awk '{print $1}')
            local commit=$(echo "$line" | awk '{print $2}')
            local branch=$(echo "$line" | awk '{print $3}')
            if [[ "$branch" == "[$branch_name]" ]]; then
                branch_dir="$dir"
                break
            fi
        done <<< "$worktree_list"

        # Check if branch directory is found
        if [[ -z "$branch_dir" ]]; then
            if [[ "$new_branch" == true ]]; then
                # Create new worktree
                git worktree add "$repo_path/$branch_name" "$branch_name"
                branch_dir=$(git worktree list | awk "/\[$branch_name\]/{print \$1}")
            else
                echo "Error: Branch directory not found for branch $branch_name" >&2
                return 1
            fi
        fi

        # Change to branch directory
        cd "$branch_dir"

    else
        # No branch name argument provided, list worktrees
        git worktree list
    fi
}
# Autocomplete branch names
_got_branch_names() {
  local branches="$(git worktree list | awk 'NR > 1 {gsub(/[][]/, "", $3); print $3}')"
  COMPREPLY=($(compgen -W "$branches" -- "${COMP_WORDS[COMP_CWORD]}"))
}
complete -F _got_branch_names got

################# ZSHRC ###############

# Check if the current shell is zsh
if [[ $(ps -p $$ | awk '{print $4}' | tail -n 1) == "zsh" ]]; then
  # Plugins currently using
  #plugins=(git zsh-syntax-highlighting zsh-autosuggestions docker)

  bindkey '^ ' autosuggest-accept

  # Edit line in vim with ctrl-backspace:
  autoload edit-command-line; zle -N edit-command-line
  bindkey '' edit-command-line

  bindkey '' backward-kill-word
  bindkey '<C-Del>' kill-word

  bindkey "" backward-word

  export EDITOR="lvim"
  export VISUAL="lvim"
fi
